# -*- coding: utf-8 -*-
"""BiasOnly.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JTqkcBtXauryOc2vQx5dUqpKis9_ylLO
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.metrics import accuracy_score, mean_squared_error
from sklearn.model_selection import train_test_split
import numpy as np
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)
torch.manual_seed(RANDOM_SEED)
torch.cuda.manual_seed(RANDOM_SEED)
torch.backends.cudnn.deterministic = True

class Config:
    """Holds model hyperparameters and data information."""
    n_items = 733
    n_users = 1340
    n_f = 5
    lamb2 = 25
    lamb3 = 10
    lamb4 = 0.0006 #0.1
    lamb5 = 0.01
    lamb6 = 0.5
    beta = 0.4
    n_epochs = 600
    lr = 0.5 #0.01
    batch_size = 1024 #2048
    global_mean_rank = 4.16275031832388

class RecommendationBias(nn.Module, BaseEstimator, ClassifierMixin):
    def __init__(self):
        super(RecommendationBias, self).__init__()
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.global_mean = torch.tensor(Config.global_mean_rank, device=self.device)
        self.BU = nn.Parameter(torch.zeros((Config.n_users, 1), device=self.device, dtype=torch.float))
        self.BI = nn.Parameter(torch.zeros((Config.n_items, 1), device=self.device, dtype=torch.float))
        self.output_layer = nn.Linear(1, 5).to(self.device)  # Ensure output_layer is on the correct device
        self.optimizer = optim.Adam([self.BU, self.BI, *self.output_layer.parameters()], lr=Config.lr)
        self.trained = False

    def forward(self, user_ids, item_ids):
        # Ensure all operations are on the same device
        bias_user = self.BU[user_ids].squeeze()
        bias_item = self.BI[item_ids].squeeze()
        pred = self.global_mean + bias_user + bias_item
        pred = self.output_layer(pred.unsqueeze(1))
        return pred

    def fit(self, X, y):
        self.to(self.device)  # Move the entire model to the device
        self.train()

        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)
        ranks = torch.tensor(pd.get_dummies(y).values.argmax(axis=1)).to(self.device)

        criterion = nn.CrossEntropyLoss()

        for epoch in range(Config.n_epochs):
            self.optimizer.zero_grad()
            pred = self.forward(user_ids, item_ids)
            loss = criterion(pred, ranks)+ 0.5 * Config.lamb4 * (torch.norm(self.BU) \
                    + torch.norm(self.BI))
            loss.backward()
            self.optimizer.step()

        self.trained = True

    def predict(self, X, y=None):
        if not self.trained:
            raise ValueError("Model has not been trained yet. Please call fit() first.")

        self.eval()
        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)

        with torch.no_grad():
            pred = self.forward(user_ids, item_ids)
            y_pred = torch.argmax(pred, dim=1).cpu().numpy()  # Move to CPU before converting to numpy

        return y_pred

    def predict_proba(self, X):
        if not self.trained:
            raise ValueError("Model has not been trained yet. Please call fit() first.")

        self.eval()
        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)

        with torch.no_grad():
            pred = self.forward(user_ids, item_ids)
            probabilities = torch.softmax(pred, dim=1)

        return probabilities.cpu().numpy()  # Move to CPU before converting to numpy

    def score(self, X, y):
        y_pred = self.predict(X)
        return accuracy_score(y, y_pred)

    def mse(self, X, y):
        y_pred = self.predict(X)
        return mean_squared_error(y, y_pred)