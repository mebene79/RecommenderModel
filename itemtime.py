# -*- coding: utf-8 -*-
"""ItemTime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MdJCXXiub1rhG9XV3EZo5QfVVfkaTzbR
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.metrics import accuracy_score, mean_squared_error
from sklearn.model_selection import train_test_split
import numpy as np
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)
torch.manual_seed(RANDOM_SEED)
torch.cuda.manual_seed(RANDOM_SEED)
torch.backends.cudnn.deterministic = True


class Config:
    """Holds model hyperparameters and data information."""
    n_items = 733
    n_users = 1340
    n_f = 5
    lamb2 = 25
    lamb3 = 10
    lamb4 = 0.0001 #0.004
    lamb5 = 0.001 #0.5
    lamb6 = 0.5
    beta = 0.4
    item_bin_size = 30 #60
    n_epochs = 600 #600
    lr = 0.02 #0.005 #0000.5
    batch_size = 1024 #2048
    global_mean_rank = 4.16275031832388

class RecommendationItem(nn.Module, BaseEstimator, ClassifierMixin):
    def __init__(self):
        super(RecommendationItem, self).__init__()
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.global_mean = torch.tensor(Config.global_mean_rank, device=self.device, dtype=torch.float32)
        self.BU = nn.Parameter(torch.zeros((Config.n_users, 1), device=self.device, dtype=torch.float32))
        self.BI = nn.Parameter(torch.zeros((Config.n_items, 1), device=self.device, dtype=torch.float32))
        self.WPI = nn.Parameter(torch.zeros((Config.n_items, 5), device=self.device, dtype=torch.float32))
        self.WPU = nn.Parameter(torch.zeros((Config.n_users, 5), device=self.device, dtype=torch.float32))
        self.WBIT = nn.Parameter(torch.zeros((Config.n_items, int(Config.item_bin_size)), device=self.device, dtype=torch.float32))
        self.output_layer = nn.Linear(1, 5).to(self.device)  # Ensure output_layer is on the correct device
        self.optimizer = optim.Adam([self.BU, self.BI,self.WPU,self.WPI,self.WBIT, *self.output_layer.parameters()], lr=Config.lr)
        self.trained = False

    def forward(self, user_ids, item_ids,ITBin):
        # Ensure all operations are on the same device


        bias_user = self.BU[user_ids].squeeze()
        bias_item = self.BI[item_ids].squeeze()
        user_factors = self.WPU[user_ids].squeeze()
        item_factors = self.WPI[item_ids].squeeze()
        bias_vector = torch.sum(user_factors * item_factors, dim=1)
        indices = torch.stack([torch.clamp(item_ids, 0, Config.n_items - 1), torch.clamp(ITBin, 0, Config.item_bin_size - 1).long()], dim=1)
        self.bias_item_binvalue = self.WBIT[indices[:, 0], indices[:, 1]]
        bias_item_time = bias_item + self.bias_item_binvalue
        pred = self.global_mean + bias_user + bias_item_time + bias_vector
        pred = self.output_layer(pred.unsqueeze(1))
        return pred

    def fit(self, X, y):
        self.to(self.device)  # Move the entire model to the device
        self.train()

        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)
        ITBin=torch.tensor(X["ITBin"].values.astype(int), device=self.device, dtype=torch.long)
        ranks = torch.tensor(pd.get_dummies(y).values.argmax(axis=1)).to(self.device)

        criterion = nn.CrossEntropyLoss()

        for epoch in range(Config.n_epochs):
            self.optimizer.zero_grad()
            pred = self.forward(user_ids, item_ids,ITBin)
            loss = criterion(pred, ranks)+ 0.5 * Config.lamb4 * (torch.norm(self.BU) \
                    + torch.norm(self.BI)+ torch.norm(self.WPU) + torch.norm(self.WPI))\
                    +0.5 * Config.lamb5 * (torch.norm(self.bias_item_binvalue))
            loss.backward()
            self.optimizer.step()

        self.trained = True

    def predict(self, X, y=None):
        if not self.trained:
            raise ValueError("Model has not been trained yet. Please call fit() first.")

        self.eval()
        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)
        ITBin=torch.tensor(X["ITBin"].values.astype(int), device=self.device, dtype=torch.long)

        with torch.no_grad():
            pred = self.forward(user_ids, item_ids,ITBin)
            y_pred = torch.argmax(pred, dim=1).cpu().numpy()  # Move to CPU before converting to numpy

        return y_pred

    def predict_proba(self, X):
        if not self.trained:
            raise ValueError("Model has not been trained yet. Please call fit() first.")

        self.eval()
        user_ids = torch.tensor(X["userID"].values.astype(int)).to(self.device)
        item_ids = torch.tensor(X["itemID"].values.astype(int)).to(self.device)
        ITBin=torch.tensor(X["ITBin"].values.astype(int)).to(self.device)

        with torch.no_grad():
            pred = self.forward(user_ids, item_ids,ITBin)
            probabilities = torch.softmax(pred, dim=1)

        return probabilities.cpu().numpy()  # Move to CPU before converting to numpy

    def score(self, X, y):
        y_pred = self.predict(X)
        return accuracy_score(y, y_pred)

    def mse(self, X, y):
        y_pred = self.predict(X)
        return mean_squared_error(y, y_pred)
